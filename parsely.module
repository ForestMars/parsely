<?php
/**
 * @file
 * The main module file.
 *
 */

define('_PARSELY_VERSION', '0.1');

/**
 * Implements hook_init().
 */
function parsely_init() {
  $apikey = variable_get('parsely_apikey', '');

  if (parsely_should_add_metas()) {
    $parsely_meta = _parsely_get_node_metadata();
    drupal_add_html_head(array(
      '#tag' => 'script',
      '#attributes' => array('type' => 'application/ld+json'),
      '#value' => json_encode($parsely_meta),
    ), 'parsely_metadata');
    drupal_add_html_head(array(
      '#tag' => 'meta',
      '#attributes' => array(
        'name' => 'drupal_parsely_version',
        'id' => 'drupal_parsely_version',
        'content' => _PARSELY_VERSION
      )
    ), 'parsely_version');
  }
}

/**
 * Implements hook_menu().
 */
function parsely_menu() {
  $items['admin/config/system/parsely'] = array(
    'title'            => 'Parse.ly',
    'description'      => 'Parse.ly configuration settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('parsely_admin_settings'),
    'access arguments' => array('administer parsely settings'),
    'type'             => MENU_NORMAL_ITEM,
    'file'             => 'parsely.admin.inc',
  );
  $items['admin/config/system/parsely/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function parsely_permission() {
  return array(
  'administer parsely settings' => array(
    'title' => t('Administer Parse.ly settings'),
  ),
  );
}

/**
 * Determines whether or not to place the parsely meta tag on a page. This is
 * separate from should_track because we don't need to consider whether users
 * are authenticated here.
 */
function parsely_should_add_metas() {
  // @todo: This needs to work on non-node pages.
  $node = menu_get_object();
  if ($node === NULL) {
    return FALSE;
  }

  $parsely_api_key = variable_get('parsely_apikey', '');
  if (empty($parsely_api_key)) {
    return FALSE;
  }

  $path = drupal_strtolower(drupal_get_path_alias($_GET['q']));
  if (drupal_match_path($path, implode("\r", parsely_paths_to_ignore()))) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Determines whether or not to place the Parsely JavaScript on a page.
 */
function parsely_should_track() {
  if (!parsely_should_add_metas()) {
    return FALSE;
  }

  // Check whether or not we should track logged in users
  $should_track_authenticated_users = variable_get('parsely_track_authenticated_users') === '0';
  if ($should_track_authenticated_users && _parsely_user_is_authenticated()) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns an array of paths not to track using Parse.ly's javascript/metadata
 * tags.
 */
function parsely_paths_to_ignore() {
  return array(
    'admin*',
    'node/add*',
    'node/*/edit*',
    'node/*/delete*',
  );
}

/**
 * Implements hook_page_build to insert Parse.ly's JavaScript tracker.
 */
function parsely_page_build(&$page) {
  if (!parsely_should_track()) {
    return;
  }

  $apikey = check_plain(variable_get('parsely_apikey'));
  $markup = <<<EOT

<!-- START Parse.ly Include: Standard -->
<div id="parsely-root" style="display: none">
  <div id="parsely-cfg" data-parsely-site="$apikey"></div>
</div>
<script>
(function(s, p, d) {
  var h=d.location.protocol, i=p+"-"+s,
    e=d.getElementById(i), r=d.getElementById(p+"-root"),
    u=h==="https:"?"d1z2jf7jlzjs58.cloudfront.net"
    :"static."+p+".com";
  if (e) return;
  e = d.createElement(s); e.id = i; e.async = true;
  e.src = h+"//"+u+"/p.js"; r.appendChild(e);
})("script", "parsely", document);
</script>
<!-- END Parse.ly Include: Standard -->
EOT;
  $page['page_bottom']['parsely'] = array('#markup' => $markup);
}


function _parsely_user_is_authenticated() {
  // Anonymous users have a uid of 0, anyone else is authenticated
  global $user;
  return $user->uid !== 0;
}

/*** Parsely Metadata Functions **********************************************/
function _parsely_get_content_id($node) {
  $prefix = variable_get('parsely_content_id_prefix', '');
  if (!empty($prefix))
    $prefix = $prefix . '-';

  return $prefix.$node->nid;
}

function _parsely_get_canonical_url($node) {
  $uri = entity_uri('node', $node);
  return url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE)));
}

function _parsely_get_authors($node) {
  return array($node->name);
}

function _parsely_get_pub_date_utc($node) {
  $pub_date = NULL;
  // Prefer published_at which is added by the publication_date module
  // https://www.drupal.org/project/publication_date
  if (property_exists($node, 'published_at') && is_numeric($node->published_at)) {
    $pub_date = $node->published_at;
  }
  // Otherwise, fall back to just Drupal's created date
  else {
    $pub_date = $node->created;
  }

  return gmdate("Y-m-d\TH:i:s\Z", $pub_date);
}

/**
 * Section is the first active term from the vocabulary we've been told to use
 * for sections.
 */
function _parsely_get_section($node) {
  $section_name = 'Uncategorized';
  $section_vocabulary = variable_get('parsely_section_vocabulary');

  if (module_exists('taxonomy') && !is_null($section_vocabulary)) {
    // Fetch the name of the first term from the given vocabulary that is
    // associated with the given node.
    $section_term_query = db_select('taxonomy_index', 'ti');
    $section_term_query->join('taxonomy_term_data', 'ttd', 'ti.tid=ttd.tid');
    $section_term_result = $section_term_query->fields('ttd', array('name'))
      ->condition('ti.nid', $node->nid)
      ->condition('ttd.vid', $section_vocabulary)
      ->orderBy('ti.created')
      ->range(0, 1)
      ->execute();

    if ($section_term_result->rowCount() > 0) {
      $section_name = $section_term_result->fetchField();
    }
  }

  // Allow any module to alter the section as it sees fit.
  // @todo: Consider passing the section term as well, if applicable.
  drupal_alter('parsely_section', $section_name, $node, $section_vocabulary);

  return $section_name;
}

function _parsely_get_tags($node) {
  $supported_vocabularies = variable_get('parsely_tag_vocabularies');
  if (!module_exists('taxonomy') || $supported_vocabularies === NULL) {
    return array();
  }

  // Fetch the names of all terms that (a) belong to one of the supported
  // vocabularies and (b) are associated with the given node.
  $active_terms_query = db_select('taxonomy_index', 'ti');
  $active_terms_query->join('taxonomy_term_data', 'ttd', 'ti.tid=ttd.tid');
  $active_terms_result = $active_terms_query->fields('ttd', array('name'))
    ->condition('ti.nid', $node->nid)
    ->condition('ttd.vid', $supported_vocabularies, 'IN')
    ->execute();

  $active_terms = array();
  if ($active_terms_result->rowCount() > 0) {
    $active_terms = $active_terms_result->fetchCol();
  }

  return $active_terms;
}

function _parsely_get_node_metadata() {
  $node = menu_get_object();

  // @todo: Integrate with metatag module and/or support tokens, etc.
  $parsely_meta = array(
    '@context'       => 'http://schema.org',
    '@type'          => 'WebPage',
    'articleId'      => _parsely_get_content_id($node),
    'headline'       => $node->title,
    'url'            => _parsely_get_canonical_url($node),
    'thumbnailUrl'   => 'FIX ME',
    'dateCreated'    => _parsely_get_pub_date_utc($node),
    'articleSection' => _parsely_get_section($node),
    'creator'        => _parsely_get_authors($node),
    'keywords'       => _parsely_get_tags($node),
  );

  if ($node->type === 'article') {
    $parsely_meta['@type'] = 'NewsArticle';
  }

  return $parsely_meta;
}
